<?php

namespace App\Commands;

use App\Services\GitHubService;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Redis;
use LaravelZero\Framework\Commands\Command;
use Prism\Prism\Enums\Provider;
use Prism\Prism\Facades\Prism;

class TriageListenCommand extends Command
{
    protected $signature = 'triage:listen';

    protected $description = 'Listen for new GitHub issues via Redis pub/sub and post AI triage plans';

    private const MAX_RECONNECT_ATTEMPTS = 10;

    private const BASE_RECONNECT_DELAY = 2;

    protected ?\Closure $sleeper = null;

    protected ?int $maxMessages = null;

    public function setSleeper(\Closure $sleeper): void
    {
        $this->sleeper = $sleeper;
    }

    public function setMaxMessages(int $max): void
    {
        $this->maxMessages = $max;
    }

    public function handle(GitHubService $github): void
    {
        $this->info('Subscribing to bifrost.github channel...');

        $this->subscribeWithReconnect($github);
    }

    protected function subscribeWithReconnect(GitHubService $github): void
    {
        $attempt = 0;

        while (true) {
            try {
                $attempt = 0;
                $messagesProcessed = 0;

                Redis::subscribe(['bifrost.github'], function (string $message) use ($github, &$messagesProcessed) {
                    $this->processMessage($message, $github);

                    $messagesProcessed++;

                    if ($this->maxMessages !== null && $messagesProcessed >= $this->maxMessages) {
                        throw new \App\Exceptions\MaxMessagesReachedException;
                    }
                });

                break;
            } catch (\App\Exceptions\MaxMessagesReachedException) {
                break;
            } catch (\Throwable $e) {
                $attempt++;

                if ($attempt > self::MAX_RECONNECT_ATTEMPTS) {
                    $this->error('Max reconnection attempts reached. Exiting.');
                    Log::error('Redis reconnection failed after '.self::MAX_RECONNECT_ATTEMPTS." attempts: {$e->getMessage()}");

                    break;
                }

                $delay = min(self::BASE_RECONNECT_DELAY * (2 ** ($attempt - 1)), 60);
                $this->warn("Redis connection lost: {$e->getMessage()}. Reconnecting in {$delay}s (attempt {$attempt}/".self::MAX_RECONNECT_ATTEMPTS.')');
                Log::warning("Redis reconnection attempt {$attempt}: {$e->getMessage()}");

                $this->sleep($delay);
            }
        }
    }

    protected function processMessage(string $message, GitHubService $github): void
    {
        try {
            $event = json_decode($message, true);

            if (! $event) {
                return;
            }

            $handler = $this->resolveHandler($event);

            if ($handler === null) {
                return;
            }

            $handler($event, $github);
        } catch (\Throwable $e) {
            $this->error("Error processing event: {$e->getMessage()}");
            Log::error("Event processing failed: {$e->getMessage()}");
        }
    }

    protected function resolveHandler(array $event): ?\Closure
    {
        $eventType = $event['eventType'] ?? null;
        $action = $event['payload']['action'] ?? null;

        $handlers = [
            'issues.opened' => fn (array $e, GitHubService $g) => $this->handleIssueOpened($e, $g),
            'issues.labeled' => fn (array $e, GitHubService $g) => $this->handleIssueLabeled($e, $g),
            'pull_request.opened' => fn (array $e, GitHubService $g) => $this->handlePullRequestOpened($e, $g),
        ];

        $key = "{$eventType}.{$action}";

        return $handlers[$key] ?? null;
    }

    protected function handleIssueOpened(array $event, GitHubService $github): void
    {
        $payload = $event['payload'];
        $repo = $payload['repository']['full_name'];
        $issue = $payload['issue'];
        $defaultBranch = $payload['repository']['default_branch'] ?? 'main';

        $this->info("Triaging issue #{$issue['number']}: {$issue['title']}");

        $tree = $github->getRepoTree($repo, $defaultBranch);

        $plan = $this->generatePlan($issue, $tree, $repo);

        $comment = "## Triage Agent\n\n{$plan}\n\n---\n*Generated by triage-agent via ".config('services.ollama.model').'*';

        $github->postComment($repo, $issue['number'], $comment);

        $this->info("Posted triage comment on {$repo}#{$issue['number']}");
    }

    protected function handleIssueLabeled(array $event, GitHubService $github): void
    {
        $payload = $event['payload'];
        $repo = $payload['repository']['full_name'];
        $issue = $payload['issue'];
        $label = $payload['label']['name'] ?? 'unknown';
        $defaultBranch = $payload['repository']['default_branch'] ?? 'main';

        $this->info("Re-triaging issue #{$issue['number']} after label \"{$label}\" added");

        $tree = $github->getRepoTree($repo, $defaultBranch);

        $plan = $this->generatePlan($issue, $tree, $repo, $label);

        $comment = "## Triage Agent (Re-triage)\n\nLabel `{$label}` was added. Updated analysis:\n\n{$plan}\n\n---\n*Generated by triage-agent via ".config('services.ollama.model').'*';

        $github->postComment($repo, $issue['number'], $comment);

        $this->info("Posted re-triage comment on {$repo}#{$issue['number']}");
    }

    protected function handlePullRequestOpened(array $event, GitHubService $github): void
    {
        $payload = $event['payload'];
        $repo = $payload['repository']['full_name'];
        $pr = $payload['pull_request'];

        $this->info("Generating PR review summary for #{$pr['number']}: {$pr['title']}");

        $summary = $this->generatePrSummary($pr, $repo);

        $comment = "## Triage Agent (PR Summary)\n\n{$summary}\n\n---\n*Generated by triage-agent via ".config('services.ollama.model').'*';

        $github->postComment($repo, $pr['number'], $comment);

        $this->info("Posted PR summary on {$repo}#{$pr['number']}");
    }

    protected function shouldProcess(?array $event): bool
    {
        if (! $event) {
            return false;
        }

        return $this->resolveHandler($event) !== null;
    }

    protected function generatePlan(array $issue, array $tree = [], string $repo = '', ?string $label = null): string
    {
        $repoContext = $this->buildRepoContext($tree, $repo);
        $labelContext = $label ? "\nThe issue was just labeled: {$label}\nConsider how this label affects prioritization and approach.\n" : '';

        $systemPrompt = <<<PROMPT
You are a senior software engineer triaging a new GitHub issue.
Analyze the issue and provide a concise implementation plan.
{$repoContext}{$labelContext}
Respond with a markdown implementation plan including:
- Summary of what needs to be done
- Suggested approach (2-4 steps)
- Key files or areas likely affected
- Potential risks or considerations

Keep it actionable and concise. Reference specific files from the repository when relevant.
PROMPT;

        $userMessage = "Issue: {$issue['title']}\n\n{$issue['body']}";

        $response = Prism::text()
            ->using(Provider::Ollama, config('services.ollama.model'))
            ->withSystemPrompt($systemPrompt)
            ->withPrompt($userMessage)
            ->withClientOptions(['timeout' => 120])
            ->asText();

        return $response->text;
    }

    protected function generatePrSummary(array $pr, string $repo): string
    {
        $systemPrompt = <<<'PROMPT'
You are a senior software engineer reviewing a pull request.
Provide a brief summary of the PR including:
- What the PR does
- Key changes to look for during review
- Any potential concerns

Keep it concise and actionable.
PROMPT;

        $body = $pr['body'] ?? '(no description)';
        $userMessage = "PR: {$pr['title']}\n\nDescription:\n{$body}\n\nChanged files: ".($pr['changed_files'] ?? 'unknown');

        $response = Prism::text()
            ->using(Provider::Ollama, config('services.ollama.model'))
            ->withSystemPrompt($systemPrompt)
            ->withPrompt($userMessage)
            ->withClientOptions(['timeout' => 120])
            ->asText();

        return $response->text;
    }

    protected function buildRepoContext(array $tree, string $repo): string
    {
        if (empty($tree)) {
            return '';
        }

        $fileList = implode("\n", array_map(fn (string $path) => "- {$path}", $tree));

        return <<<CONTEXT

Repository: {$repo}
Project structure:
{$fileList}

CONTEXT;
    }

    protected function sleep(int $seconds): void
    {
        if ($this->sleeper) {
            ($this->sleeper)($seconds);
        } else {
            sleep($seconds);
        }
    }
}
